필기

JUnit => property 라이브러리에서 내장 라이브러리 추가하기. 

XML 파싱 => 컨테이너에 등록

SingleTon이므로, 객체명이 다르더라도, 같은 객체를 사용하고 있음.

DI는 Setter를 통해 값 주입 or 생성자()를 통해 주입.

c	 : 생성자의 매개변수에 값을 주입.
		p	 : 멤버변수의 초기
		util : properties파일을 읽어서 주입
		
		DL: 클래스 찾기 (getBean())
		DI: 값 주입
			setter 이용 / 생성자 이용  
		컨테이너 동작 순서 
			1) 객체 생성 
			   Class className=Class.forName()
			   	=> 생성자 매개변수를 이용한 값 주입
			2) Setter를 이용한 멤버변수 초기화
			3) 사용자가 지정한 메소드 호출
			=========================================================
			4) ============================= 개발자가 필요한 메소드 호출 사용
			5) 객체 소멸
			========================================================= Spring 담당 (객체 생성, 호출)
			
			singleton : 메모리 공간을 공유 (default)
			prototype : 메모리를 복제해서 사용 (다른 메모리가 생성됨)
						=> clone(객체를 다른 메모리에 복제)
						
						
		public class Member{
			private String id, name;
			public Member(String id, String name){
				this.id=id;
				this.name=name;
			}
		}
		Member m = new Member(); (X) 
		Member m = new Member("hong","홍길동"); (O) 
		매개변수가 맞지 않으므로.. 
	
--------------------------------------------------------------------------------
	
	MainClass는 Hello클래스에 의존을 한다.
		=> 결합성이 강한 프로그램 (의존성이 강한 프로그램)
		=> 장점 : 연결하기 쉽다 / 단점 : 변경시에 다른 클래스에 영향력이 강하다.
		
			스프링에서는 방지 (의존성이 낮은 프로그램 작성)
			=> 클래스 수정 => 다른 클래스에 영향이 없게 만든다.
			=> 스프링에서는 가급적 new를 사용하지 않는다.
			
		인터페이스는 메인과 메소드를 연결하는 역할
		=> 의존성을 낮추기 위함.
		
		Spring => Class 여러개를 묶어서 관리하는 Container 역할 (클래스 관리자)
		
		interface 사용시,리팩토링을 거쳐도 본인 클래스에만 에러 발생.
		
--------------------------------------------------------------------------------
		
		객체 생성과 동시에 값을 주입 : DI
				멤버변수의 초기화
				setXxx() / 생성자 
				메소드 호출이 가능 ==> 객체 생성시 (init-method)
								   객체 소멸시 (destroy-method)

--------------------------------------------------------------------------------

 Member 클래스의 멤버변수에 값을 채운 후에 메모리 할당
			@Getter
			@Setter
			public class Member{
				private String id, name, sex;
				public Member(){
					setId("hong")
					setName("gildong")
					setSex("man")
				}
			}
			ApplicationContext
				=> HashMap
			key		address
			===============
			mem		Class.forName("com.sist.main2.Member") => 100
			mem		100
			sa		200
			std		300
			
-------------------------------------------------------------------------------

	!!메모리 할당 및 호출 순서!!
	
	<bean id="a" class="A"/>
	1. 메모리 할당 => 생성자 호출
	2. setter DI => setXxx() 값을 채운다. (순서 상관 없음)
	3. init-method에 등록된 메소드 호출
	4. 개발자에 의해 사용자 정의 메소드 호출
	5. destroy-method 호출 => 메모리 해제 
		
-------------------------------------------------------------------------------

	s.init(); => 스프링 자체에서 처리 
	but! 동시에 3개의 init이 실행될 경우, 
	클래스 메모리 할당과 동시에 init 메소드를 호출하기 때문에
	init 메소드 3개가 처음에 동시에 호출되면서 순서가 어긋남.
	m.init으로 개별 메소드 호출 필요